/**
 * LLM System Prompts for flow generation and adaptation
 */

import type { FlowMetadata, FlowStep, FlowSession } from "../types.js";

/**
 * System prompt for flow generation
 */
export function getFlowGenerationSystemPrompt(): string {
  return `You are an expert at designing multi-step conversational workflows for Clawdbot.

User flows are defined as JSON objects with the following schema:

- name: string (lowercase-hyphenated, e.g., "morning-routine")
- description: string (brief description of the flow's purpose)
- version: string (semantic version, e.g., "1.0.0")
- author: string (optional, defaults to "Generated by AI")
- steps: array of step objects

Each step object has:
- id: string (unique identifier)
- message: string (conversational text shown to user)
- buttons: array (optional - button values: strings, numbers, or objects with {text, value, next})
- capture: string (optional - variable name to capture user input)
- validate: string (optional - "number", "email", or "phone")
- next: string (optional - next step id)
- condition: object (optional - conditional branching with {variable, equals/greaterThan/lessThan/contains, next})

Best practices:
1. Use clear, conversational language in messages
2. Keep steps focused on one question/action
3. Use descriptive step IDs (e.g., "intro", "set1", "feedback")
4. Add validation when capturing structured data
5. Use buttons for common responses (easier than typing)
6. Design logical flow progression
7. Consider conditional branching for personalization
8. The last step should have no "next" field (flow completes)

Return ONLY valid JSON matching the schema. Do not include markdown code blocks or explanations.`;
}

/**
 * Build user prompt for flow generation
 */
export function buildFlowGenerationPrompt(
  request: string,
  examples?: FlowMetadata[],
  context?: string
): string {
  let prompt = "";

  // Add examples if provided
  if (examples && examples.length > 0) {
    prompt += "Here are some example flows for reference:\n\n";
    examples.forEach((example, idx) => {
      prompt += `Example ${idx + 1}:\n`;
      prompt += JSON.stringify(example, null, 2);
      prompt += "\n\n";
    });
  }

  // Add context if provided (e.g., user history)
  if (context) {
    prompt += `Context:\n${context}\n\n`;
  }

  // Add user request
  prompt += `User request: ${request}\n\n`;
  prompt += "Generate a complete, valid flow JSON:";

  return prompt;
}

/**
 * System prompt for step adaptation
 */
export function getStepAdaptationSystemPrompt(): string {
  return `You are adapting a conversational workflow step to be more engaging and personalized based on the user's session context.

Your goal is to:
1. Make the message more conversational and natural based on what the user has shared
2. Keep it encouraging and supportive
3. Adapt button labels to be contextual (if applicable)
4. Maintain the same meaning and intent
5. Keep messages concise (1-2 sentences)

Return ONLY valid JSON in this format:
{
  "message": "adapted message text",
  "buttons": ["label1", "label2", ...] // Optional: new button labels (same count, same order)
}

Do not include markdown code blocks or explanations.`;
}

/**
 * Build user prompt for step adaptation
 */
export function buildStepAdaptationPrompt(
  step: FlowStep,
  session: FlowSession,
  options: {
    includeVariables?: boolean;
    includeFlowMetadata?: boolean;
    adaptButtons?: boolean;
  }
): string {
  let prompt = `Current step:\n`;
  prompt += `- ID: ${step.id}\n`;
  prompt += `- Message: "${step.message}"\n`;

  if (step.buttons && step.buttons.length > 0) {
    prompt += `- Buttons: ${JSON.stringify(step.buttons)}\n`;
  }

  if (options.includeVariables && Object.keys(session.variables).length > 0) {
    prompt += `\nUser context:\n`;
    prompt += `- Flow: ${session.flowName}\n`;
    prompt += `- Variables captured: ${JSON.stringify(session.variables, null, 2)}\n`;
  }

  prompt += `\nAdapt the step to be more contextual and engaging`;

  if (options.adaptButtons && step.buttons && step.buttons.length > 0) {
    prompt += ` (including button labels)`;
  }

  prompt += `:`;

  return prompt;
}

/**
 * Validate flow generation response
 */
export function validateFlowGenerationResponse(
  response: unknown
): { valid: boolean; error?: string } {
  if (typeof response !== "object" || response === null) {
    return { valid: false, error: "Response is not an object" };
  }

  const flow = response as Record<string, unknown>;

  // Check required fields
  if (!flow.name || typeof flow.name !== "string") {
    return { valid: false, error: "Missing or invalid 'name' field" };
  }
  if (!flow.description || typeof flow.description !== "string") {
    return { valid: false, error: "Missing or invalid 'description' field" };
  }
  if (!flow.version || typeof flow.version !== "string") {
    return { valid: false, error: "Missing or invalid 'version' field" };
  }
  if (!Array.isArray(flow.steps) || flow.steps.length === 0) {
    return { valid: false, error: "Missing or invalid 'steps' field" };
  }

  // Check steps
  for (let i = 0; i < flow.steps.length; i++) {
    const step = flow.steps[i] as Record<string, unknown>;
    if (!step.id || typeof step.id !== "string") {
      return { valid: false, error: `Step ${i}: missing or invalid 'id'` };
    }
    if (!step.message || typeof step.message !== "string") {
      return { valid: false, error: `Step ${i}: missing or invalid 'message'` };
    }
  }

  return { valid: true };
}

/**
 * Validate step adaptation response
 */
export function validateStepAdaptationResponse(response: unknown): {
  valid: boolean;
  error?: string;
  message?: string;
  buttons?: string[];
} {
  if (typeof response !== "object" || response === null) {
    return { valid: false, error: "Response is not an object" };
  }

  const adapted = response as Record<string, unknown>;

  if (!adapted.message || typeof adapted.message !== "string") {
    return { valid: false, error: "Missing or invalid 'message' field" };
  }

  let buttons: string[] | undefined;
  if (adapted.buttons !== undefined) {
    if (!Array.isArray(adapted.buttons)) {
      return { valid: false, error: "'buttons' must be an array" };
    }
    // Validate all buttons are strings
    if (!adapted.buttons.every((b) => typeof b === "string")) {
      return { valid: false, error: "All button labels must be strings" };
    }
    buttons = adapted.buttons as string[];
  }

  return {
    valid: true,
    message: adapted.message as string,
    buttons,
  };
}
